<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Tetonor Mobile</title>

  <!-- PWA (single-file-ish): manifest por data: URL -->
  <link id="manifestLink" rel="manifest" href="">
  <meta name="theme-color" content="#ffffff" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <style>
    :root{
      --bg:#ffffff;
      --ink:#0b0f1a;
      --muted:#667085;
      --line:#111111;
      --soft:#e6e8ee;

      --chip:#f2f4f7;
      --card:#ffffff;

      --yellow:#f4b400;     /* + */
      --green:#34a853;      /* × */
      --gray:#cbd5e1;

      --r-lg:18px;
      --r:14px;
      --r-sm:12px;

      --shadow: 0 8px 28px rgba(15, 23, 42, .10);
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(52,168,83,.12), transparent 55%),
        radial-gradient(1200px 700px at 80% -10%, rgba(244,180,0,.10), transparent 55%),
        #fff;
      color:var(--ink);
    }

    /* Layout: todo entra en 100svh, sin scroll normal.
       Cuando "Solución" está ON, habilitamos scroll en el área central para que no recorte. */
    .app{
      height:100svh;
      display:flex;
      flex-direction:column;
      padding:8px;
      gap:8px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:6px 9px;
      border-radius: var(--r-lg);
      background: rgba(255,255,255,.85);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      border:1px solid rgba(15,23,42,.08);
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .logo{
      font-weight:900;
      letter-spacing:.6px;
      font-size:15px;
      line-height:1;
      padding:7px 9px;
      border-radius: 11px;
      background: linear-gradient(180deg, rgba(15,23,42,.06), rgba(15,23,42,.02));
      border:1px solid rgba(15,23,42,.08);
      white-space:nowrap;
    }
    .sub{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
    }
    .sub .mini{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .rowBtns{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:nowrap;
    }

    /* Botones superiores: “ligeramente más chicos” */
    .btn{
      border:1px solid rgba(15,23,42,.12);
      background: #fff;
      border-radius: 12px;
      padding:6px 9px;
      font-weight:800;
      font-size:11px;
      cursor:pointer;
      box-shadow: 0 4px 16px rgba(15,23,42,.06);
      display:flex;
      align-items:center;
      gap:6px;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(15,23,42,.06), rgba(15,23,42,.02));
    }
    .btn.toggleOn{
      border-color: rgba(15,23,42,.20);
      background: linear-gradient(180deg, rgba(52,168,83,.12), rgba(52,168,83,.05));
    }
    .btn.icon{
      padding:6px 8px;
      width:34px;
      justify-content:center;
    }

    .difficulty{
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 8px;
      border-radius: 12px;
      border:1px solid rgba(15,23,42,.12);
      background:#fff;
      box-shadow: 0 4px 16px rgba(15,23,42,.06);
      font-size:12px;
      font-weight:900;
      color: var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .difficulty select{
      border:1px solid rgba(15,23,42,.14);
      border-radius:10px;
      padding:5px 8px 5px 10px;
      font:inherit;
      font-weight:900;
      color:#0b0f1a;
      background:#f8fafc;
    }

    .main{
      display:flex;
      flex-direction:column;
      gap:8px;
      flex:1;
      min-height:0;
    }

    /* Grid section */
    .panel{
      border-radius: var(--r-lg);
      background: rgba(255,255,255,.9);
      border:1px solid rgba(15,23,42,.08);
      box-shadow: var(--shadow);
      padding:6px;
      min-height:0;
    }
    .gridWrap{
      border:2px solid #111;
      border-radius: 14px;
      background:#fff;
      padding:4px;
      min-height:0;
      overflow:hidden; /* default: sin scroll */
    }
    .gridWrap.scrollable{
      overflow:auto; /* cuando solución ON, permitimos scroll y NO recortamos celdas */
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:6px;
    }

    .cell{
      border:2px solid #111;
      border-radius: 12px;
      background:#fff;
      padding:6px 6px;
      min-height:60px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      gap:5px;
      position:relative;
      user-select:none;
      touch-action:none;
    }

    .cellTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:8px;
    }
    .target{
      font-weight:1000;
      font-size:16px;
      line-height:1;
    }

    .opPill{
      width:26px; height:26px;
      border-radius: 9px;
      display:grid;
      place-items:center;
      font-weight:1000;
      font-size:13px;
      border:1px solid rgba(15,23,42,.12);
      background: var(--chip);
      color:#111;
      flex:0 0 auto;
    }
    .opPill.add{
      background: rgba(244,180,0,.18);
      border-color: rgba(244,180,0,.35);
      color: #7a4b00;
    }
    .opPill.mul{
      background: rgba(52,168,83,.16);
      border-color: rgba(52,168,83,.32);
      color: #0f5a2a;
    }

    .expr{
      font-size:11.5px;
      color: rgba(15,23,42,.85);
      font-weight:900;
      padding:5px 7px;
      border-radius: 11px;
      background: rgba(15,23,42,.04);
      border:1px dashed rgba(15,23,42,.14);
      min-height:28px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
    }

    .solLine{
      font-size:10.5px;
      color: var(--muted);
      font-weight:800;
      display:none;
    }
    .revealOn .solLine{ display:block; }

    .cell.ok{
      box-shadow: 0 0 0 3px rgba(52,168,83,.18) inset;
    }
    .cell.bad{
      box-shadow: 0 0 0 3px rgba(220, 38, 38, .16) inset;
    }

    /* Pairs */
    .pairsWrap{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-height:0;
    }
    .pairsGrid{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:6px;
      min-height:0;
    }
    .pairCard{
      border:2px solid #111;
      border-radius: 12px;
      background:#fff;
      padding:5px 10px;
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      gap:12px;
      user-select:none;
      position:relative;
      min-height:48px;
      touch-action:none;
    }
    .pairSlot{
      width:100%; height:32px;
      border-radius: 12px;
      background: #fff;
      border:1px dashed rgba(15,23,42,.20);
      display:grid;
      place-items:center;
      font-weight:1000;
      color:#111;
      overflow:hidden;
      position:relative;
      touch-action:none;
    }
    .pairSlot.filled{
      border-style:solid;
      background: var(--chip);
    }
    .pairOps{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
      justify-content:center;
      min-width:0;
      width:34px;
    }
    .marks{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:center;
      flex:0 0 auto;
    }
    .mark{
      width:28px;height:28px;
      border-radius: 999px;
      display:grid;
      place-items:center;
      font-weight:1000;
      font-size:12px;
      border:1px solid rgba(15,23,42,.12);
      background: var(--chip);
      color: rgba(15,23,42,.5);
    }
    .mark.add.on{
      background: rgba(244,180,0,.22);
      border-color: rgba(244,180,0,.38);
      color:#7a4b00;
    }
    .mark.mul.on{
      background: rgba(52,168,83,.20);
      border-color: rgba(52,168,83,.34);
      color:#0f5a2a;
    }
    .mark.over{
      box-shadow: 0 0 0 3px rgba(220,38,38,.14) inset;
      border-color: rgba(220,38,38,.35);
      color: rgba(220,38,38,.92);
      background: rgba(220,38,38,.06);
    }

    /* Numbers pool */
    .numsGrid{
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      gap:6px;
    }
    .numTok{
      border:2px solid #111;
      border-radius: 12px;
      background:#fff;
      min-height:36px;
      display:grid;
      place-items:center;
      font-weight:1000;
      user-select:none;
      position:relative;
      touch-action:none;
    }
    .numTok.used{
      opacity:.38;
    }

    /* editable number: input */
    .numTok .in{
      width:100%;
      height:100%;
      border:0;
      outline:0;
      font: inherit;
      font-weight:1000;
      text-align:center;
      background: transparent;
      color: #111;
    }
    .numTok.edit{
      background: rgba(15,23,42,.03);
    }

    /* Drag ghost */
    .ghost{
      position:fixed;
      left:0; top:0;
      transform: translate(-9999px,-9999px);
      pointer-events:none;
      z-index:200;
      background:#fff;
      border:2px solid #111;
      border-radius: 14px;
      padding:10px 12px;
      font-weight:1000;
      box-shadow: 0 12px 30px rgba(15,23,42,.18);
    }
    .dropHot{
      box-shadow: 0 0 0 3px rgba(15,23,42,.18) inset;
    }
    .pairCard.dropHot{
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37,99,235,.18) inset;
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(15,23,42,.92);
      color:#fff;
      font-size:12px;
      font-weight:800;
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      z-index:250;
      pointer-events:none;
      max-width: calc(100vw - 24px);
      text-align:center;
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(-4px); }

    /* Modal */
    .back{
      position:fixed; inset:0;
      background: rgba(2,6,23,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:300;
    }
    .back.show{ display:flex; }
    .modal{
      width:100%;
      max-width:560px;
      background:#fff;
      border-radius: 18px;
      border:1px solid rgba(15,23,42,.12);
      box-shadow: 0 20px 60px rgba(2,6,23,.25);
      overflow:hidden;
    }
    .mHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(15,23,42,.10);
      font-weight:1000;
    }
    .mBody{
      padding:12px 14px 14px 14px;
      color: rgba(15,23,42,.92);
      font-size:13px;
      line-height:1.45;
    }
    .mBody ul{ margin:8px 0 0 18px; }
    .mBody li{ margin:6px 0; }
    .mFoot{
      padding:10px 14px 14px 14px;
      display:flex;
      gap:10px;
      justify-content:flex-end;
    }

    .footer{
      padding:8px 10px;
      border-radius: var(--r-lg);
      background: linear-gradient(135deg, rgba(15,23,42,.04), rgba(15,23,42,.02));
      border:1px solid rgba(15,23,42,.08);
      box-shadow: var(--shadow);
      font-size:11px;
      color: rgba(15,23,42,.78);
      text-align:center;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .footer .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:12px;
      background:#0b0f1a;
      color:#f8fafc;
      text-decoration:none;
      box-shadow: 0 8px 20px rgba(15,23,42,.18);
      font-weight:900;
    }
    .footer .pill span{ opacity:.9; font-weight:700; }

    /* Confetti canvas */
    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:260;
    }
  </style>
</head>

<body>
  <canvas id="confetti"></canvas>

  <div class="app" id="appRoot">
    <div class="topbar">
      <div class="brand">
        <div class="logo">TETONOR</div>
        <div class="sub">
          <div class="mini" id="miniStatus"></div>
          <div class="mini" id="miniHint"></div>
        </div>
      </div>

      <div class="rowBtns">
        <button class="btn primary" id="btnNew">NUEVO</button>
        <button class="btn" id="btnReveal">SOLUCIÓN</button>
        <button class="btn icon" id="btnHelp" title="Help">?</button>

        <div class="difficulty" title="Dificultad">
          <label for="diffSelect" id="diffLabel">DIF</label>
          <select id="diffSelect" aria-label="Difficulty"></select>
        </div>
      </div>
    </div>

    <div class="main">
      <!-- GRID -->
      <div class="panel">
        <div class="gridWrap" id="gridWrap">
          <div class="grid" id="grid"></div>
        </div>
      </div>

      <!-- PAIRS -->
      <div class="panel pairsWrap">
        <div class="pairsGrid" id="pairsGrid"></div>
      </div>

      <!-- NUMBERS -->
      <div class="panel">
        <div class="numsGrid" id="numsGrid"></div>
      </div>
    </div>

    <div class="footer" id="footer"></div>
  </div>

  <div class="ghost" id="ghost"></div>
  <div class="toast" id="toast"></div>

  <!-- Help modal -->
  <div class="back" id="back">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <div class="mHead">
        <div id="helpTitle">Ayuda</div>
        <button class="btn icon" id="btnClose">✕</button>
      </div>
      <div class="mBody" id="helpBody"></div>
      <div class="mFoot">
        <button class="btn" id="btnClose2">OK</button>
      </div>
    </div>
  </div>

  <script>
    // =========================================================
    // i18n
    // =========================================================
    let LANG = (navigator.language || "es").toLowerCase().startsWith("es") ? "es" : "en";

    const I18N = {
      es: {
        new:"NUEVO",
        sol:"SOLUCIÓN",
        help:"Ayuda",
        grid:"Grilla",
        pairs:"Pares",
        nums:"Números",
        hint:"",
        statusReady:"",
        statusWin:"¡Victoria! ✅",
        statusErr:"Hay errores ❌",
        needFill:"Completá los huecos y armá tarjetas.",
        diff:"NV",
        diffTip:"Dificultad = cantidad de huecos (0 = más fácil)",
        numsHint:(holes)=> holes===0 ? "sin huecos" : (holes===1 ? "1 hueco" : `${holes} huecos`),
        helpBody: `
          <b>Controles</b>
          <ul>
            <li><b>Tap</b> en una celda de la grilla: cambia operación (vacío → <span style="color:#7a4b00;font-weight:900">+</span> → <span style="color:#0f5a2a;font-weight:900">×</span>).</li>
            <li>Arrastrá números al <b>pool de pares</b> para armar 8 tarjetas.</li>
            <li><b>Doble tap / doble click</b> sobre un número en una tarjeta: lo suelta (desvincula).</li>
            <li>Arrastrá una tarjeta a una celda de la grilla.</li>
            <li>Regla: cada tarjeta debe usarse <b>una vez en +</b> y <b>una vez en ×</b>.</li>
            <li><b>Cualquier solución válida</b> cuenta como victoria.</li>
          </ul>
        `,
        toastNew:"Nuevo puzzle listo.",
        toastRevealOn:"Mostrando solución (puede scrollear).",
        toastRevealOff:"Ocultando solución.",
        toastNeedNumber:"Ese número todavía está vacío.",
        toastTokenUsed:"Ese número ya está usado en otra tarjeta.",
        toastCardNotReady:"Esa tarjeta no está completa.",
        toastNeedCard:"Arrastrá una tarjeta primero.",
        toastStripOrder:"La pool debe estar ordenada (ascendente).",
        toastMissing:"Falta completar cosas.",
        toastWin:"¡Perfecto!",
        footer:`<span>Si te gustó, visitá mi tienda 3D</span><a class="pill" href="https://cults3d.com/es/usuarios/PINGUE3D/modelos-3d" target="_blank" rel="noreferrer noopener">Cults · <span>PINGÜÉ3D</span></a><span><b>Mateo</b></span>`
      },
      en: {
        new:"NEW",
        sol:"SOLUTION",
        help:"Help",
        grid:"Grid",
        pairs:"Pairs",
        nums:"Numbers",
        hint:"",
        statusReady:"",
        statusWin:"Victory! ✅",
        statusErr:"There are errors ❌",
        needFill:"Fill blanks and build cards.",
        diff:"LVL",
        diffTip:"Difficulty = number of blanks (0 = easiest)",
        numsHint:(holes)=> holes===0 ? "no blanks" : (holes===1 ? "1 blank" : `${holes} blanks`),
        helpBody: `
          <b>Controls</b>
          <ul>
            <li><b>Tap</b> a grid cell: cycles operation (empty → <span style="color:#7a4b00;font-weight:900">+</span> → <span style="color:#0f5a2a;font-weight:900">×</span>).</li>
            <li>Drag numbers into the <b>pair pool</b> to build 8 cards.</li>
            <li><b>Double tap / double click</b> a number inside a card: release it.</li>
            <li>Drag a card into a grid cell.</li>
            <li>Rule: each card must be used <b>once in +</b> and <b>once in ×</b>.</li>
            <li><b>Any valid solution</b> counts as a win.</li>
          </ul>
        `,
        toastNew:"New puzzle ready.",
        toastRevealOn:"Showing solution (scroll enabled).",
        toastRevealOff:"Hiding solution.",
        toastNeedNumber:"That number is still blank.",
        toastTokenUsed:"That number is already used by another card.",
        toastCardNotReady:"That card is incomplete.",
        toastNeedCard:"Drag a card first.",
        toastStripOrder:"The pool must be ascending.",
        toastMissing:"Something is missing.",
        toastWin:"Perfect!",
        footer:`<span>If you enjoyed it, check my 3D shop</span><a class="pill" href="https://cults3d.com/en/users/PINGUE3D/3d-models" target="_blank" rel="noreferrer noopener">Cults · <span>PINGÜÉ3D</span></a><span><b>Mateo</b></span>`
      }
    };

    const t = (k, ...args) => {
      const v = I18N[LANG][k];
      return (typeof v === "function") ? v(...args) : v;
    };

    // =========================================================
    // State + puzzle generation
    // =========================================================
    const gridEl = document.getElementById("grid");
    const pairsEl = document.getElementById("pairsGrid");
    const numsEl = document.getElementById("numsGrid");
    const miniStatus = document.getElementById("miniStatus");
    const miniHint = document.getElementById("miniHint");
    const gridWrap = document.getElementById("gridWrap");
    const appRoot = document.getElementById("appRoot");

    const btnNew = document.getElementById("btnNew");
    const btnReveal = document.getElementById("btnReveal");
    const btnHelp = document.getElementById("btnHelp");

    const diffSelect = document.getElementById("diffSelect");
    const diffLabel = document.getElementById("diffLabel");

    const back = document.getElementById("back");
    const helpBody = document.getElementById("helpBody");
    const helpTitle = document.getElementById("helpTitle");
    const btnClose = document.getElementById("btnClose");
    const btnClose2 = document.getElementById("btnClose2");

    const footer = document.getElementById("footer");
    const toastEl = document.getElementById("toast");

    let reveal = false;
    let hasWon = false;

    const S = {
      difficulty: 5, // cantidad de huecos (0 = más fácil)
      strip: [],     // [{value:number|null, isBlank:boolean}]
      stripGuess: Array(16).fill(null),
      // pair cards: 8 cards, each slot stores stripIdx or null
      cards: Array.from({length:8}, ()=>({a:null,b:null,lastSlot:null})),
      // grid: 16 cells, each has cardId or null + op null/+/*
      grid: Array.from({length:16}, ()=>({cardId:null, op:null})),
      // hidden solution (solo para mostrar cuando reveal ON)
      solution: { fullStrip:[], solPairs:[], cells:[] }
    };

    for(let i=0;i<=12;i++){
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = String(i);
      diffSelect.appendChild(opt);
    }

    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }

    function genFullStrip(){
      // 16 números ordenados, con repetidos permitidos
      const nums=[];
      let cur=randInt(1,6);
      for(let i=0;i<16;i++){
        const step = (Math.random()<0.42)?0:(Math.random()<0.78?1:randInt(2,3));
        cur = Math.min(cur + step, 48);
        nums.push(cur);
      }
      nums.sort((a,b)=>a-b);
      return nums;
    }

    function maskStrip(full, holes){
      // holes = cantidad de huecos (0 = fácil)
      const idxs = new Set();
      while(idxs.size < holes){
        const i = randInt(0,15);
        if(i===0 || i===15) continue; // extremos fijos para mantener orden más fácil
        idxs.add(i);
      }
      return full.map((v,i)=>({ value: idxs.has(i) ? null : v, isBlank: idxs.has(i) }));
    }

    function genSolutionPairs(){
      const idxs=[...Array(16)].map((_,i)=>i);
      shuffle(idxs);
      const pairs=[];
      for(let i=0;i<16;i+=2) pairs.push([idxs[i], idxs[i+1]]);
      return pairs; // 8 pares
    }

    function genTargets(fullStrip, solPairs){
      // 16 celdas: por cada par -> una suma y un producto
      const cells=[];
      for(let p=0;p<8;p++){
        const [i1,i2]=solPairs[p];
        const a=fullStrip[i1], b=fullStrip[i2];
        cells.push({target:a+b, op:"+", pairId:p});
        cells.push({target:a*b, op:"x", pairId:p});
      }
      shuffle(cells);
      return cells;
    }

    function newGame(){
      const fullStrip = genFullStrip();
      const solPairs = genSolutionPairs();
      const cells = genTargets(fullStrip, solPairs);

      S.solution.fullStrip = fullStrip.slice();
      S.solution.solPairs = solPairs.map(p=>p.slice());
      S.solution.cells = cells.map(c=>({...c}));

      S.strip = maskStrip(fullStrip, S.difficulty);
      S.stripGuess = Array(16).fill(null);
      S.cards = Array.from({length:8}, ()=>({a:null,b:null,lastSlot:null}));
      S.grid  = Array.from({length:16}, ()=>({cardId:null, op:null}));

      reveal = false;
      hasWon = false;
      btnReveal.classList.remove("toggleOn");

      renderAll();
      toast(t("toastNew"));
      setStatus(t("statusReady"));
    }

    // =========================================================
    // Derived helpers
    // =========================================================
    function stripValueAt(i){
      const item = S.strip[i];
      if(!item.isBlank) return item.value;
      return S.stripGuess[i];
    }

    function stripTokenUsed(i){
      return S.cards.some(c=>c.a===i || c.b===i);
    }

    function cardReady(cardId){
      const c=S.cards[cardId];
      if(c.a===null || c.b===null) return false;
      const a = stripValueAt(c.a);
      const b = stripValueAt(c.b);
      return (a!==null && b!==null);
    }

    function cardValues(cardId){
      const c=S.cards[cardId];
      const a = (c.a===null) ? null : stripValueAt(c.a);
      const b = (c.b===null) ? null : stripValueAt(c.b);
      return {a,b};
    }

    function orderOK(){
      const vals = Array.from({length:16},(_,i)=>stripValueAt(i));
      for(let i=1;i<16;i++){
        if(vals[i]!==null && vals[i-1]!==null && vals[i] < vals[i-1]) return false;
      }
      return true;
    }

    function gridComputed(i){
      const g=S.grid[i];
      if(g.cardId===null || g.op===null) return null;
      if(!cardReady(g.cardId)) return null;
      const {a,b}=cardValues(g.cardId);
      if(a===null || b===null) return null;
      return g.op==="+" ? (a+b) : (a*b);
    }

    function cardUsage(){
      const usage = Array.from({length:8}, ()=>({add:0,mul:0}));
      S.grid.forEach(g=>{
        if(g.cardId===null || g.op===null) return;
        if(g.op==="+") usage[g.cardId].add++;
        else usage[g.cardId].mul++;
      });
      return usage;
    }

    // =========================================================
    // Rendering (con preservación de foco)
    // =========================================================
    function snapshotFocus(){
      const a = document.activeElement;
      if(!a) return null;
      if(a.tagName === "INPUT" && a.dataset && a.dataset.stripIdx){
        return {
          stripIdx: parseInt(a.dataset.stripIdx,10),
          start: a.selectionStart,
          end: a.selectionEnd
        };
      }
      return null;
    }
    function restoreFocus(snap){
      if(!snap) return;
      const inp = document.querySelector(`input[data-strip-idx="${snap.stripIdx}"]`);
      if(!inp) return;
      inp.focus({preventScroll:true});
      try{
        inp.setSelectionRange(snap.start ?? inp.value.length, snap.end ?? inp.value.length);
      }catch(_){}
    }

    function applyTexts(){
      document.documentElement.setAttribute("lang", LANG);
      btnNew.textContent = t("new");
      btnReveal.textContent = t("sol");
      btnHelp.title = t("help");
      helpTitle.textContent = t("help");
      helpBody.innerHTML = t("helpBody");

      miniHint.textContent = t("hint");

      diffLabel.textContent = t("diff");
      document.querySelector(".difficulty").title = t("diffTip");
      diffSelect.value = String(S.difficulty);

      footer.innerHTML = I18N[LANG].footer;
    }

    function renderAll(){
      const snap = snapshotFocus();

      applyTexts();
      renderNumbers();
      renderPairs();
      renderGrid();
      renderStatusLine();

      restoreFocus(snap);

      // check auto-win after any interaction
      checkVictory(false);
    }

    function renderStatusLine(){
      miniStatus.textContent = orderOK() ? t("statusReady") : t("toastStripOrder");
    }

    function renderNumbers(){
      numsEl.innerHTML = "";
      for(let i=0;i<16;i++){
        const item = S.strip[i];
        const val = stripValueAt(i);
        const used = stripTokenUsed(i);

        const tok = document.createElement("div");
        tok.className = "numTok" + (used ? " used":"") + (item.isBlank ? " edit":"");
        tok.dataset.kind = "token";
        tok.dataset.stripIdx = String(i);

        if(item.isBlank){
          const inp = document.createElement("input");
          inp.className = "in";
          inp.inputMode = "numeric";
          inp.pattern = "[0-9]*";
          inp.placeholder = "—";
          inp.value = (val===null ? "" : String(val));
          inp.dataset.stripIdx = String(i);     // para restaurar foco
          inp.setAttribute("data-strip-idx", String(i));

          // FIX foco: NO re-render “agresivo” que te saca del input.
          // Solo actualizamos el estado y luego re-render con restoreFocus (arriba).
          inp.addEventListener("input", ()=>{
            const clean = inp.value.replace(/[^\d]/g,"");
            if(inp.value !== clean) inp.value = clean;
            S.stripGuess[i] = (clean==="" ? null : parseInt(clean,10));
            // Re-render completo pero restaurando foco y caret
            renderAll();
          });

          tok.appendChild(inp);
        }else{
          tok.textContent = String(item.value);
        }

        // Marcar fuera de orden (solo si hay valores vecinos)
        const v = stripValueAt(i);
        if(v!==null){
          const prev = i>0 ? stripValueAt(i-1) : null;
          const next = i<15 ? stripValueAt(i+1) : null;
          let ok=true;
          if(prev!==null && v<prev) ok=false;
          if(next!==null && v>next) ok=false;
          if(!ok) tok.style.boxShadow = "0 0 0 3px rgba(220,38,38,.14) inset";
          else tok.style.boxShadow = "";
        }

        // Custom drag (touch + mouse): token -> pairSlot
        attachDragToken(tok);

        numsEl.appendChild(tok);
      }
    }

    function renderPairs(){
      pairsEl.innerHTML = "";
      const usage = cardUsage();

      for(let c=0;c<8;c++){
        const card = document.createElement("div");
        card.className = "pairCard";
        card.dataset.kind = "card";
        card.dataset.cardId = String(c);

        const addOn = usage[c].add>0;
        const mulOn = usage[c].mul>0;

        const aIdx = S.cards[c].a;
        const bIdx = S.cards[c].b;
        const aVal = (aIdx===null) ? null : stripValueAt(aIdx);
        const bVal = (bIdx===null) ? null : stripValueAt(bIdx);

        card.innerHTML = `
          <div class="pairSlot ${aIdx!==null ? "filled":""}" data-slot="a">${aVal??""}</div>
          <div class="pairOps">
            <div class="marks">
              <div class="mark add ${addOn?"on":""} ${usage[c].add>1?"over":""}">+</div>
              <div class="mark mul ${mulOn?"on":""} ${usage[c].mul>1?"over":""}">×</div>
            </div>
          </div>
          <div class="pairSlot ${bIdx!==null ? "filled":""}" data-slot="b">${bVal??""}</div>
        `;

        // Drop target for tokens on each slot
        card.querySelectorAll(".pairSlot").forEach(slot=>{
          const which = slot.getAttribute("data-slot"); // a/b
          attachDropPairSlot(slot, c, which);

          // FIX #5: doble click / doble tap en la tarjeta => desvincula
          let lastTap=0;
          slot.addEventListener("click", (e)=>{
            e.stopPropagation();
            const now = Date.now();
            if(now - lastTap < 320){
              // double tap
              if(S.cards[c][which]!==null){
                clearCardSlot(c, which);
                renderAll();
              }
            }
            lastTap = now;
          });
          slot.addEventListener("dblclick", (e)=>{
            e.stopPropagation();
            if(S.cards[c][which]!==null){
              clearCardSlot(c, which);
              renderAll();
            }
          });
        });

        // Double tap/click on card clears both slots
        let lastCardTap = 0;
        card.addEventListener("click", (e)=>{
          const now = Date.now();
          if(now - lastCardTap < 320){
            if(clearCardSlots(c)) renderAll();
          }
          lastCardTap = now;
        });
        card.addEventListener("dblclick", (e)=>{
          if(clearCardSlots(c)) renderAll();
        });

        // Drop target on full card for auto-slotting
        attachDropPairCard(card, c);

        // Drag card -> grid cell (touch + mouse)
        attachDragCard(card);

        pairsEl.appendChild(card);
      }
    }

    function renderGrid(){
      // cuando reveal ON, habilitar scroll en gridWrap
      gridWrap.classList.toggle("scrollable", reveal);
      appRoot.classList.toggle("revealOn", reveal);

      gridEl.innerHTML = "";

      for(let i=0;i<16;i++){
        const cellDef = S.solution.cells[i]; // targets (mismos targets siempre)
        const target = cellDef.target;
        const g = S.grid[i];

        const computed = gridComputed(i);
        const isComplete = computed!==null;
        const isCorrect = isComplete && computed===target;

        const cell = document.createElement("div");
        cell.className = "cell" + (isComplete ? (isCorrect ? " ok":" bad") : "");
        cell.dataset.kind = "gridCell";
        cell.dataset.cellIdx = String(i);

        let opClass="", opText="—";
        if(g.op==="+"){ opClass="add"; opText="+"; }
        else if(g.op==="x"){ opClass="mul"; opText="×"; }

        // expression line
        let expr="—";
        if(g.cardId!==null){
          const {a,b}=cardValues(g.cardId);
          const sym = g.op===null ? "—" : (g.op==="+"?"+":"×");
          expr = `${a??"—"} ${sym} ${b??"—"}`;
        }

        // reveal line shows the generated solution for THAT cell (one possible)
        let solLine = "";
        if(reveal){
          const sol = S.solution.cells[i];
          const [i1,i2] = S.solution.solPairs[sol.pairId];
          const a = S.solution.fullStrip[i1];
          const b = S.solution.fullStrip[i2];
          const sym = (sol.op==="x") ? "×" : "+";
          solLine = `Sol: ${a} ${sym} ${b}`;
        }

        cell.innerHTML = `
          <div class="cellTop">
            <div class="target">${target}</div>
            <div class="opPill ${opClass}">${opText}</div>
          </div>
          <div class="expr">${expr}</div>
          <div class="solLine">${solLine}</div>
        `;

        // Tap cycles op: null -> + -> x -> null (even if no card placed yet)
        cell.addEventListener("click", ()=>{
          if(g.op===null) g.op="+";
          else if(g.op==="+") g.op="x";
          else g.op=null;
          renderAll();
        });

        // clear on double tap / dblclick
        let lastTap=0;
        cell.addEventListener("click", ()=>{
          const now=Date.now();
          if(now-lastTap<320){
            S.grid[i]={cardId:null, op:null};
            renderAll();
          }
          lastTap=now;
        });
        cell.addEventListener("dblclick", ()=>{
          S.grid[i]={cardId:null, op:null};
          renderAll();
        });

        // drop card
        attachDropGridCell(cell, i);

        gridEl.appendChild(cell);
      }
    }

    // =========================================================
    // Victory: “cualquier solución válida”
    // =========================================================
    function checkVictory(showToasts=true){
      // 1) blanks filled
      for(let i=0;i<16;i++){
        if(S.strip[i].isBlank && stripValueAt(i)===null){
          hasWon = false;
          if(showToasts) toast(t("toastMissing"));
          return false;
        }
      }
      // 2) strip ascending
      if(!orderOK()){
        hasWon = false;
        if(showToasts) toast(t("toastStripOrder"));
        return false;
      }
      // 3) pair cards full (16 slots)
      const filledPairSlots = S.cards.reduce((acc,c)=> acc + (c.a!==null?1:0) + (c.b!==null?1:0), 0);
      if(filledPairSlots < 16){
        hasWon = false;
        if(showToasts) toast(t("needFill"));
        return false;
      }
      // 4) grid complete
      const filledGrid = S.grid.filter(g=>g.cardId!==null && g.op!==null).length;
      if(filledGrid < 16){
        hasWon = false;
        if(showToasts) toast(t("toastMissing"));
        return false;
      }
      // 5) each cell hits target
      for(let i=0;i<16;i++){
        const target = S.solution.cells[i].target;
        const computed = gridComputed(i);
        if(computed !== target){
          hasWon = false;
          if(showToasts) toast(t("statusErr"));
          return false;
        }
      }
      // 6) each card used exactly once in + and once in ×
      const usage = cardUsage();
      const okUsage = usage.every(u=>u.add===1 && u.mul===1);
      if(!okUsage){
        hasWon = false;
        if(showToasts) toast(t("statusErr"));
        return false;
      }

      // WIN
      setStatus(t("statusWin"));
      if(showToasts) toast(t("toastWin"));
      if(!hasWon){
        confettiBurst();
        hasWon = true;
      }
      return true;
    }

    // =========================================================
    // UI actions
    // =========================================================
    function setStatus(msg){
      miniStatus.textContent = msg;
    }
    function toast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.classList.remove("show"), 1400);
    }

    btnNew.addEventListener("click", newGame);

    btnReveal.addEventListener("click", ()=>{
      reveal = !reveal;
      btnReveal.classList.toggle("toggleOn", reveal);
      if(reveal) toast(t("toastRevealOn"));
      else toast(t("toastRevealOff"));
      renderAll();
    });

    btnHelp.addEventListener("click", ()=>{
      back.classList.add("show");
    });
    function closeModal(){ back.classList.remove("show"); }
    btnClose.addEventListener("click", closeModal);
    btnClose2.addEventListener("click", closeModal);
    back.addEventListener("click", (e)=>{ if(e.target===back) closeModal(); });
    document.addEventListener("keydown",(e)=>{ if(e.key==="Escape") closeModal(); });

    // Dificultad “al revés”: 0 = 0 huecos (más fácil)
    diffSelect.addEventListener("input", ()=>{
      S.difficulty = parseInt(diffSelect.value,10);
    });
    diffSelect.addEventListener("change", ()=>{
      // al cambiar dificultad, generamos puzzle nuevo
      newGame();
    });

    // =========================================================
    // Drag system (touch + mouse)
    //   - token drag -> pairSlot
    //   - card drag  -> grid cell
    // Requirements:
    //  3) input no pierde foco tras 1 dígito: solucionado con restoreFocus
    //  4) editable tokens se pueden arrastrar clickeando en cualquier parte:
    //     implementamos drag propio en el wrapper .numTok (incluye input).
    // =========================================================
    const ghost = document.getElementById("ghost");
    let drag = null; // {type:"token"/"card", ...}

    function point(e){
      if(e.touches && e.touches[0]) return {x:e.touches[0].clientX, y:e.touches[0].clientY};
      return {x:e.clientX, y:e.clientY};
    }

    function attachDragToken(tok){
      const stripIdx = parseInt(tok.dataset.stripIdx,10);

      // Start drag on pointerdown (also works when user taps on input area)
      tok.addEventListener("pointerdown", (e)=>{
        // if empty value, can't drag
        const v = stripValueAt(stripIdx);
        if(v===null){ return; }
        if(stripTokenUsed(stripIdx)){ return; }

        if(tok.setPointerCapture){
          try{ tok.setPointerCapture(e.pointerId); }catch(err){}
        }

        // Allow editing: if it's an input and user just taps, don't drag.
        // We'll only start drag if movement threshold is exceeded.
        const start = { ...point(e) };
        let moved = false;

        function onMove(ev){
          const p = point(ev);
          const dx = p.x - start.x, dy = p.y - start.y;
          if(!moved && (dx*dx + dy*dy) > 36){
            moved = true;

            // If dragging from an input, blur it so it doesn't “cortar” el drag
            const inp = tok.querySelector("input");
            if(inp && document.activeElement === inp) inp.blur();

            drag = { type:"token", stripIdx };
            ghost.textContent = String(stripValueAt(stripIdx));
            ghost.style.transform = `translate(${p.x+10}px, ${p.y+10}px)`;
            highlightDropTargets("token");
            ev.preventDefault();
          }
          if(moved && drag){
            ghost.style.transform = `translate(${p.x+10}px, ${p.y+10}px)`;
            updateHotTarget(p.x, p.y);
            ev.preventDefault();
          }
        }

        function endDrag(ev){
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", endDrag);
          window.removeEventListener("pointercancel", endDrag);
          if(drag){
            const p = point(ev);
            performDrop(p.x, p.y);
          }
          cleanupDrag();
        }

        window.addEventListener("pointermove", onMove, {passive:false});
        window.addEventListener("pointerup", endDrag);
        window.addEventListener("pointercancel", endDrag);
      });

      // Desktop HTML5 drag (fallback)
      tok.draggable = true;
      tok.addEventListener("dragstart",(e)=>{
        const v = stripValueAt(stripIdx);
        if(v===null || stripTokenUsed(stripIdx)){
          e.preventDefault();
          return;
        }
        e.dataTransfer.setData("text/plain", `token:${stripIdx}`);
        e.dataTransfer.effectAllowed = "copy";
      });
    }

    function attachDropPairSlot(slot, cardId, which){
      // HTML5 drop fallback
      slot.addEventListener("dragover",(e)=>{ e.preventDefault(); });
      slot.addEventListener("drop",(e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain") || "";
        if(raw.startsWith("token:")){
          const stripIdx = parseInt(raw.slice(6),10);
          assignTokenToSlot(stripIdx, cardId, which);
        }
      });
    }

    function attachDropPairCard(card, cardId){
      card.addEventListener("dragover",(e)=>{ e.preventDefault(); });
      card.addEventListener("drop",(e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain") || "";
        if(raw.startsWith("token:")){
          const stripIdx = parseInt(raw.slice(6),10);
          const slot = nextSlotForCard(cardId);
          assignTokenToSlot(stripIdx, cardId, slot);
        }
      });
    }

    function attachDragCard(card){
      const cardId = parseInt(card.dataset.cardId,10);

      card.addEventListener("pointerdown",(e)=>{
        if(!cardReady(cardId)) return;

        if(card.setPointerCapture){
          try{ card.setPointerCapture(e.pointerId); }catch(err){}
        }

        const start = { ...point(e) };
        let moved = false;

        function onMove(ev){
          const p = point(ev);
          const dx = p.x - start.x, dy = p.y - start.y;
          if(!moved && (dx*dx + dy*dy) > 36){
            moved = true;
            drag = { type:"card", cardId };
            ghost.textContent = "▦";
            ghost.style.transform = `translate(${p.x+10}px, ${p.y+10}px)`;
            highlightDropTargets("card");
            ev.preventDefault();
          }
          if(moved && drag){
            ghost.style.transform = `translate(${p.x+10}px, ${p.y+10}px)`;
            updateHotTarget(p.x, p.y);
            ev.preventDefault();
          }
        }
        function endDrag(ev){
          window.removeEventListener("pointermove", onMove);
          window.removeEventListener("pointerup", endDrag);
          window.removeEventListener("pointercancel", endDrag);
          if(drag){
            const p = point(ev);
            performDrop(p.x, p.y);
          }
          cleanupDrag();
        }

        window.addEventListener("pointermove", onMove, {passive:false});
        window.addEventListener("pointerup", endDrag);
        window.addEventListener("pointercancel", endDrag);
      });

      // HTML5 fallback
      card.draggable = true;
      card.addEventListener("dragstart",(e)=>{
        if(!cardReady(cardId)){ e.preventDefault(); return; }
        e.dataTransfer.setData("text/plain", `card:${cardId}`);
        e.dataTransfer.effectAllowed = "copy";
      });
    }

    function attachDropGridCell(cell, cellIdx){
      cell.addEventListener("dragover",(e)=>{ e.preventDefault(); });
      cell.addEventListener("drop",(e)=>{
        e.preventDefault();
        const raw = e.dataTransfer.getData("text/plain") || "";
        if(raw.startsWith("card:")){
          const cardId = parseInt(raw.slice(5),10);
          if(!cardReady(cardId)){ toast(t("toastCardNotReady")); return; }
          S.grid[cellIdx].cardId = cardId;
          // no seteamos op automáticamente: el usuario toca para elegir
          renderAll();
        }
      });
    }

    function nextSlotForCard(cardId){
      const c = S.cards[cardId];
      if(c.a===null) return "a";
      if(c.b===null) return "b";
      return c.lastSlot ?? "b";
    }

    function setCardSlot(cardId, which, stripIdx){
      const c = S.cards[cardId];
      c[which] = stripIdx;
      c.lastSlot = which;
    }

    function clearCardSlot(cardId, which){
      const c = S.cards[cardId];
      c[which] = null;
      if(c.a!==null && c.b!==null){
        c.lastSlot = which === "a" ? "b" : "a";
      }else if(c.a!==null){
        c.lastSlot = "a";
      }else if(c.b!==null){
        c.lastSlot = "b";
      }else{
        c.lastSlot = null;
      }
    }

    function clearCardSlots(cardId){
      const c = S.cards[cardId];
      const had = (c.a!==null || c.b!==null);
      if(c.a!==null) clearCardSlot(cardId, "a");
      if(c.b!==null) clearCardSlot(cardId, "b");
      return had;
    }

    function assignTokenToSlot(stripIdx, cardId, which){
      if(stripValueAt(stripIdx)===null){ toast(t("toastNeedNumber")); return; }
      if(stripTokenUsed(stripIdx)){ toast(t("toastTokenUsed")); return; }

      setCardSlot(cardId, which, stripIdx);
      renderAll();
    }

    // Drag helpers
    function highlightDropTargets(kind){
      clearHot();
      if(kind==="token"){
        document.querySelectorAll(".pairSlot, .pairCard").forEach(el=>el.classList.add("dropTarget"));
      }else{
        document.querySelectorAll(".cell").forEach(el=>el.classList.add("dropTarget"));
      }
    }
    function clearHot(){
      document.querySelectorAll(".dropHot").forEach(el=>el.classList.remove("dropHot"));
    }

    function elementFromPointSafe(x,y){
      // Sometimes ghost overlays; temporarily hide it
      const old = ghost.style.display;
      ghost.style.display = "none";
      const el = document.elementFromPoint(x,y);
      ghost.style.display = old;
      return el;
    }

    function updateHotTarget(x,y){
      clearHot();
      const el = elementFromPointSafe(x,y);
      if(!el) return;

      if(drag?.type==="token"){
        const slot = el.closest(".pairSlot");
        const card = el.closest(".pairCard");
        if(slot) slot.classList.add("dropHot");
        else if(card) card.classList.add("dropHot");
      }else if(drag?.type==="card"){
        const cell = el.closest(".cell");
        if(cell) cell.classList.add("dropHot");
      }
    }

    function performDrop(x,y){
      const el = elementFromPointSafe(x,y);
      if(!el) return;

      if(drag.type==="token"){
        const cardEl = el.closest(".pairCard");
        if(!cardEl) return;
        const cardId = parseInt(cardEl.dataset.cardId,10);
        const slotEl = el.closest(".pairSlot");
        const which = slotEl ? slotEl.getAttribute("data-slot") : nextSlotForCard(cardId);
        assignTokenToSlot(drag.stripIdx, cardId, which);
      }else if(drag.type==="card"){
        const cell = el.closest(".cell");
        if(!cell) return;
        const cellIdx = parseInt(cell.dataset.cellIdx,10);
        if(!cardReady(drag.cardId)){ toast(t("toastCardNotReady")); return; }
        S.grid[cellIdx].cardId = drag.cardId;
        renderAll();
      }
    }

    function cleanupDrag(){
      drag = null;
      ghost.style.transform = "translate(-9999px,-9999px)";
      clearHot();
      document.querySelectorAll(".dropTarget").forEach(el=>el.classList.remove("dropTarget"));
    }

    // =========================================================
    // Confetti
    // =========================================================
    const confCanvas = document.getElementById("confetti");
    const ctx = confCanvas.getContext("2d");
    let confettiParts = [];
    let confettiRunning=false;

    function resizeConfetti(){
      confCanvas.width = window.innerWidth;
      confCanvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resizeConfetti);
    resizeConfetti();

    function confettiBurst(){
      const W=confCanvas.width, H=confCanvas.height;
      const n=160;
      const ox=W/2, oy=H*0.18;
      for(let i=0;i<n;i++){
        const ang = Math.random()*Math.PI*2;
        const spd = 3 + Math.random()*7;
        confettiParts.push({
          x:ox, y:oy,
          vx:Math.cos(ang)*spd,
          vy:Math.sin(ang)*spd + 2,
          g:0.14 + Math.random()*0.20,
          w:4 + Math.random()*6,
          h:6 + Math.random()*10,
          r:Math.random()*Math.PI,
          vr:(Math.random()-0.5)*0.25,
          life:140 + Math.random()*70,
          a:1
        });
      }
      if(!confettiRunning){
        confettiRunning=true;
        requestAnimationFrame(confettiTick);
      }
    }

    function confettiTick(){
      const W=confCanvas.width, H=confCanvas.height;
      ctx.clearRect(0,0,W,H);

      confettiParts = confettiParts.filter(p=>p.life>0);
      for(const p of confettiParts){
        p.life--;
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.r += p.vr;
        if(p.life<40) p.a = Math.max(0,p.life/40);

        ctx.save();
        ctx.globalAlpha=p.a;
        ctx.translate(p.x,p.y);
        ctx.rotate(p.r);

        // Paleta cercana a tu esquema (verde/amarillo/gris) pero variada:
        const pick = Math.random();
        let fill="#94a3b8";
        if(pick<0.45) fill="rgba(52,168,83,.92)";
        else if(pick<0.85) fill="rgba(244,180,0,.92)";
        ctx.fillStyle=fill;

        ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
        ctx.restore();
      }

      if(confettiParts.length){
        requestAnimationFrame(confettiTick);
      }else{
        confettiRunning=false;
        ctx.clearRect(0,0,W,H);
      }
    }

    // =========================================================
    // PWA: manifest + service worker embebidos
    // =========================================================
    (function setupPWA(){
      const manifest = {
        name: "Tetonor",
        short_name: "Tetonor",
        start_url: ".",
        display: "standalone",
        background_color: "#ffffff",
        theme_color: "#ffffff",
        icons: [
          // Icono simple (data URI SVG)
          {
            src: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='192' height='192'%3E%3Crect width='192' height='192' rx='36' fill='%23ffffff'/%3E%3Crect x='14' y='14' width='164' height='164' rx='30' fill='%230b0f1a' opacity='.06'/%3E%3Ctext x='96' y='112' text-anchor='middle' font-family='Arial' font-size='56' font-weight='900' fill='%230b0f1a'%3ET%3C/text%3E%3C/svg%3E",
            sizes: "192x192",
            type: "image/svg+xml"
          }
        ]
      };
      const manifestUrl = "data:application/manifest+json," + encodeURIComponent(JSON.stringify(manifest));
      document.getElementById("manifestLink").href = manifestUrl;

      // Service worker via Blob URL
      const swCode = `
        const CACHE = "tetonor-mobile-v1";
        self.addEventListener("install", (e) => {
          e.waitUntil((async()=>{
            const cache = await caches.open(CACHE);
            // cache the root shell (single file)
            await cache.addAll(["./"]);
            self.skipWaiting();
          })());
        });
        self.addEventListener("activate", (e) => {
          e.waitUntil((async()=>{
            const keys = await caches.keys();
            await Promise.all(keys.map(k => k===CACHE ? null : caches.delete(k)));
            self.clients.claim();
          })());
        });
        self.addEventListener("fetch", (e) => {
          e.respondWith((async()=>{
            const cached = await caches.match(e.request, {ignoreSearch:true});
            if(cached) return cached;
            try{
              const res = await fetch(e.request);
              const cache = await caches.open(CACHE);
              cache.put(e.request, res.clone()).catch(()=>{});
              return res;
            }catch(err){
              return cached || new Response("Offline", {status: 503});
            }
          })());
        });
      `;
      const swBlob = new Blob([swCode], {type:"text/javascript"});
      const swUrl = URL.createObjectURL(swBlob);

      if("serviceWorker" in navigator){
        navigator.serviceWorker.register(swUrl).catch(()=>{});
      }
    })();

    // =========================================================
    // Boot
    // =========================================================
    newGame();
  </script>
</body>
</html>
